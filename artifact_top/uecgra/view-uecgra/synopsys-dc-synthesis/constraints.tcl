#=========================================================================
# Design Constraints File
#=========================================================================

# This constraint sets the target clock period for the chip in
# nanoseconds. Note that the first parameter is the name of the clock
# signal in your verlog design. If you called it something different than
# clk you will need to change this. You should set this constraint
# carefully. If the period is unrealistically small then the tools will
# spend forever trying to meet timing and ultimately fail. If the period
# is too large the tools will have no trouble but you will get a very
# conservative implementation.

set clock_net  clk
set clock_name ideal_clock

# `clk` is the input clock to be divided
create_clock -name ${clock_name} \
             -period [expr ${dc_clock_period}/3.0] \
             [get_ports ${clock_net}]

# Clocks generated by clock dividers
# We don't need to set the exact ratio for these clocks -- use
# the target clock frequency for STA and let suppression logic
# deal with unsafe crossings

create_generated_clock -name ideal_div_clk1 -edges {1 3 5} \
                       [get_pins cd1/clk_divided] \
                       -source [get_ports ${clock_net}]

create_generated_clock -name ideal_div_clk2 -edges {1 10 19} \
                       [get_pins cd2/clk_divided] \
                       -source [get_ports ${clock_net}]

create_generated_clock -name ideal_div_clk3 -edges {1 4 7} \
                       [get_pins cd3/clk_divided] \
                       -source [get_ports ${clock_net}]

# Create switched clock for each tile

for {set tile_idx 0} {${tile_idx} < 64} {incr tile_idx} {
  create_generated_clock -name ideal_switched_clk${tile_idx} \
                         -divide_by 1 -combinational -add \
                         [get_ports tiles__${tile_idx}/clk_switcher/clk_out] \
                         -source [get_ports cd3/clk_divided] \
                         -master_clock ideal_div_clk3
}

# STA should assume that all clocks are selecting nominal
for {set tile_idx 0} {${tile_idx} < 64} {incr tile_idx} {
  set_case_analysis 1 cfg__${tile_idx}__clk_self[1]
  set_case_analysis 0 cfg__${tile_idx}__clk_self[0]
}

# Clock-gating checks for the clock switcher
#
# Here is actually what I want to check:
#
#   - Setup: Check that for each clk1_select->clk1->clk_out, the select
#     arrives before the clk reaches high phase (avoid glitch there)
#
#   - Hold: impossible, set false path here
#
#   - CDC: if select goes low, check that the path from select to clk_out
#     is zeroed (shorter) before the path of another select clocks in,
#     waits for its neg phase, and asserts clk_out
#       - short version, check that the path from select_reg to clk_out is
#         shorter than the shortest clk's neg phase
#       - ^ setup check
#
#   - CDC: if select goes high, nothing matters... other clks are
#     deselected already...
#
# But we don't have time to get this exactly right, and honestly I expect
# we do not have to _force_ the tool to honor these constraints (e.g.,
# there are basically two gates to compute clk_out from the clk selects,
# and the setup checks allow half a clock cycle to do it).
#
# For now, just disable these clock-gating checks.. we are not taping out.

set_disable_clock_gating_check [get_cells -hierarchical *clk_switcher*]

# This constraint sets the load capacitance in picofarads of the
# output pins of your design.

set_load -pin_load $ADK_TYPICAL_ON_CHIP_LOAD [all_outputs]

# This constraint sets the input drive strength of the input pins of
# your design. We specifiy a specific standard cell which models what
# would be driving the inputs. This should usually be a small inverter
# which is reasonable if another block of on-chip logic is driving
# your inputs.

set_driving_cell -no_design_rule \
  -lib_cell $ADK_DRIVING_CELL [all_inputs]

# Set false paths to handle config, clk selection, reset, clk_reset, imm
set_false_path -from cfg*

set_false_path -from clksel*en*
set_false_path -from clksel*msg*
set_false_path -to clksel*rdy*

set_false_path -from reset*
set_false_path -from clk_reset*

set_false_path -from imm*

# set_input_delay constraints for input ports
#
# - make this non-zero to avoid hold buffers on input-registered designs

# At CGRA level we are model SRAMs placed next to the tiles so we set 
# input delays to 0 ( that provides enough time for inputs to arrive )

set_input_delay -clock ideal_div_clk3 [expr 0.0*${dc_clock_period}] [all_inputs]

# set_output_delay constraints for output ports

# Same applies for outputs

set_output_delay -clock ideal_div_clk3 [expr 0.0*${dc_clock_period}] [all_outputs]

# Handle feedthrough

set_input_delay -clock ideal_div_clk3 [expr 0.0*${dc_clock_period}] [get_ports send*rdy*]
set_output_delay -clock ideal_div_clk3 0 [get_ports send*en*]

# Make all signals limit their fanout

set_max_fanout 20 $dc_design_name

# Make all signals meet good slew

set_max_transition [expr 0.25*${dc_clock_period}] $dc_design_name

#set_input_transition 1 [all_inputs]
#set_max_transition 10 [all_outputs]

# Set all paths from input and to output as false path
# This will not hurt tile-to-tile timing analysis
set_false_path -from [all_inputs]
set_false_path -to   [all_outputs]

# Disable hold check for CDCs
set_false_path -hold -from ideal_div_clk1 -to ideal_div_clk2
set_false_path -hold -from ideal_div_clk2 -to ideal_div_clk1
set_false_path -hold -from ideal_div_clk1 -to ideal_div_clk3
set_false_path -hold -from ideal_div_clk3 -to ideal_div_clk1
set_false_path -hold -from ideal_div_clk2 -to ideal_div_clk3
set_false_path -hold -from ideal_div_clk3 -to ideal_div_clk2
