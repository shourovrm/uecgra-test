#=========================================================================
# SVTranslator.py
#=========================================================================
# Author : Peitian Pan
# Date   : March 15, 2019
"""Provide SystemVerilog translator."""

from pymtl3.passes.rtlir import RTLIRType as rt
from pymtl3.passes.translator import RTLIRTranslator

from .behavioral import SVBehavioralTranslator as SV_BTranslator
from .structural import SVStructuralTranslator as SV_STranslator

sverilog_keyword = [
  # Verilog-1995 reserved keywords
  "always", "and", "assign", "begin", "buf", "bufif0", "bufif1", "case",
  "casex", "casez", "cmos", "deassign", "default", "defparam", "disable",
  "edge", "else", "end", "endcase", "endmodule", "endfunction", "endprimitive",
  "endspecify", "endtable", "endtask", "event", "for", "force", "forever",
  "fork", "function", "highz0", "highz1", "if", "ifnone", "initial",
  "inout", "input", "output", "integer", "join", "large", "macromodule",
  "medium", "module", "nand", "negedge", "nmos", "nor", "not", "notif0",
  "notif1", "or", "output", "parameter", "pmos", "posedge", "primitive",
  "pull0", "pull1", "pullup", "pulldown", "rcmos", "real", "realtime",
  "reg", "release", "repeat", "rnmos", "rpmos", "rtran", "rtranif0",
  "rtranif1", "scalared", "small", "specify", "specparam", "strong0",
  "strong1", "supply0", "supply1", "table", "task", "time", "tran",
  "tranif0", "tranif1", "tri", "tri0", "tri1", "triand", "trior",
  "trireg", "vectored", "wait", "wand", "weak0", "weak1", "while",
  "wire", "wor", "xnor", "xor",
  # Verilog-2001 reserved keywords
  "automatic", "cell", "config", "design", "endconfig", "endgenerate",
  "generate", "genvar", "incdir", "include", "instance", "liblist",
  "library", "localparam", "noshowcancelled", "pulsestyle_onevent",
  "pulsestyle_ondetect", "showcancelled", "signed", "unsigned", "use",
  # Verilog-2005 reserved keywords
  "uwire",
  # SystemVerilog-2005 reserved keywords
  "alias", "always_comb", "always_ff", "always_latch", "assert", "assume",
  "before", "bind", "bins", "binsof", "bit", "break", "byte", "chandle",
  "class", "clocking", "const", "constraint", "context", "continue",
  "cover", "covergroup", "coverpoint", "cross", "dist", "do", "endclass",
  "endclocking", "endgroup", "endinterface", "endpackage", "endprimitive",
  "endprogram", "endproperty", "endsequence", "enum", "expect", "export",
  "extends", "extern", "final", "first_match", "foreach", "forkjoin",
  "iff", "ignore_bins", "illegal_bins", "import", "inside", "int", "interface",
  "intersect", "join_any", "join_none", "local", "logic", "longint", "matches",
  "modport", "new", "null", "package", "packed", "priority", "program",
  "property", "protected", "pure", "rand", "randc", "randcase", "randsequence",
  "ref", "return", "sequence", "shortint", "shortreal", "solve", "static",
  "string", "struct", "super", "tagged", "this", "throughout", "timeprecision",
  "timeunit", "type", "typedef", "union", "unique", "var", "virtual", "void",
  "wait_order", "wildcard", "with", "within"
]
sverilog_reserved = set( sverilog_keyword )

def mk_SVTranslator( _RTLIRTranslator, _STranslator, _BTranslator ):

  class _SVTranslator( _RTLIRTranslator, _STranslator, _BTranslator ):

    def get_pretty( s, namespace, attr, newline=True ):
      ret = getattr(namespace, attr, "")
      if newline and (ret and ret[-1] != '\n'):
        ret += "\n"
      return ret

    def is_sverilog_reserved( s, name ):
      return name in sverilog_reserved

    def set_header( s ):
      s.header = \
"""\
//-------------------------------------------------------------------------
// {name}.sv
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

"""

    def rtlir_tr_src_layout( s, hierarchy ):
      s.set_header()
      name = s._top_module_full_name
      ret = s.header.format( **locals() )

      # Add struct definitions
      for struct_dtype, tplt in hierarchy.decl_type_struct:
        template = \
"""\
// Definition of PyMTL BitStruct {dtype_name}
// {file_info}
{struct_def}\
"""
        dtype_name = struct_dtype.get_name()
        file_info = struct_dtype.get_file_info()
        struct_def = tplt['def'] + '\n'
        ret += template.format( **locals() )

      # Add component sources
      ret += hierarchy.component_src
      return ret

    def rtlir_tr_components( s, components ):
      return "\n\n".join( components )

    def generate_sv_blackbox( s, behavioral, structural ):
      comp = s.cur_component
      path = comp.sverilog_translate.get_v_src()
      rtype = comp._pass_structural_rtlir_gen.rtlir_type
      all_params = rtype.get_params()
      component_name = structural.component_name
      s._top_module_full_name = structural.component_unique_name + "_blackbox"

      with open(path, "r") as v_src:
        src = f"// This file is copied from {path}" + '\n' + \
              f"{''.join(v_src.readlines())}" + '\n' + \
              f"// End of copied file {path}" + '\n' + \
              "//====================================\n"

      # If this component has no parameters, just return the file source
      if not all_params:
        s.black_box_components[component_name] = src
        return src

      # Else we need to create a wrapper that instantiates the module with
      # correct parameters
      # TODO: currently no name mangle is performed; need to have a clean way
      # to perform consistent name mangling across all passes in one backend.
      # Also this only supports individual ports.
      all_ports = rtype.get_ports_packed()
      assert not rtype.get_ifc_views_packed(), "No support for interfaces yet"
      for id_, port in all_ports:
        assert isinstance(port, rt.Port), "No support for arrays yet"
      # Ports
      ports = [
        f"  {p.get_direction()} logic [{p.get_dtype().get_length()}-1:0]"\
        f" {name}{'' if idx == len(all_ports)-1 else ','}" \
        for idx, (name, p) in enumerate(all_ports)]
      # Parameters
      params = [
        f"    .{param}( {val} ){'' if idx == len(all_params)-1 else ','}"\
        for idx, (param, val) in enumerate(all_params)]
      # Connections
      connect_ports = [
        f"    .{name}( {name} ){'' if idx == len(all_ports)-1 else ','}"\
        for idx, (name, p) in enumerate(all_ports)]
      # Wrapper
      wrapper_lines = [
        f"// This is a wrapper that instantiates {component_name} with parameters.",
        f"module {structural.component_unique_name}",
        "(",
      ] + ports + [
        ");",
        f"  {component_name}",
        "  #(",
      ] + params + [
        "  ) wrapped_module",
        "  (",
      ] + connect_ports + [
        "  );",
        "endmodule",
      ]

      if component_name in s.black_box_components:
        # If v_src has been included, only include the wrapper
        return "\n".join(line for line in wrapper_lines)
      else:
        # Include v_src if it's the first time we see this component
        s.black_box_components[component_name] = src
        return src + "\n" + "\n".join(line for line in wrapper_lines)

    def rtlir_tr_component( s, behavioral, structural ):

      if hasattr(s.cur_component, "sverilog_translate") and \
         s.cur_component.sverilog_translate.get_v_src():
        return s.generate_sv_blackbox(behavioral, structural)

      template =\
"""\
// Definition of PyMTL Component {component_name}
// {file_info}
// Full name: {full_name}
module {module_name}
(
{ports});
{body}
endmodule
"""
      component_name = getattr( structural, "component_name" )
      file_info = getattr( structural, "component_file_info" )
      ports_template = "{port_decls}{ifc_decls}"
      full_name = getattr( structural, "component_full_name" )
      module_name = getattr( structural, "component_unique_name" )

      port_decls = s.get_pretty(structural, 'decl_ports', False)
      ifc_decls = s.get_pretty(structural, 'decl_ifcs', False)
      if port_decls or ifc_decls:
        if port_decls and ifc_decls:
          port_decls += ',\n'
        ifc_decls += '\n'
      ports = ports_template.format(**locals())

      const_decls = s.get_pretty(structural, "decl_consts")
      fvar_decls = s.get_pretty(behavioral, "decl_freevars")
      wire_decls = s.get_pretty(structural, "decl_wires")
      tmpvar_decls = s.get_pretty(behavioral, "decl_tmpvars")
      subcomp_decls = s.get_pretty(structural, "decl_subcomps")
      upblk_decls = s.get_pretty(behavioral, "upblk_decls")
      body = const_decls + fvar_decls + wire_decls + subcomp_decls \
           + tmpvar_decls + upblk_decls
      connections = s.get_pretty(structural, "connections")
      if (body and connections) or (not body and connections):
        connections = '\n' + connections
      body += connections

      s._top_module_name = getattr( structural, "component_name", module_name )
      s._top_module_full_name = module_name
      return template.format( **locals() )

  return _SVTranslator

SVTranslator = mk_SVTranslator( RTLIRTranslator, SV_STranslator, SV_BTranslator )
